[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial: DAA_DES",
    "section": "",
    "text": "This project simulates the operations of the Devon Air Ambulance (DAA) service using a Discrete Event Simulation (DES) model. It models the journey of patients requiring emergency care, tracks the availability and allocation of HEMS resources (helicopters and cars), and allows users to explore different scenarios (like changing shift patterns or demand levels) via a web interface. The goal is to understand how resource changes impact performance metrics like response times and resource utilization, using statistical distributions to mimic real-world variability.\nSource Repository: https://github.com/RichardPilbery/DAA_DES\n\n\n\n\n\nflowchart TD\n    A0[\"Simulation Engine (Patient Journey)\n\"]\n    A1[\"Patient Entity\n\"]\n    A2[\"HEMS Resource Entity\n\"]\n    A3[\"Resource Management (Availability & Allocation)\n\"]\n    A4[\"Simulation Runner & Parallelization\n\"]\n    A5[\"Stochastic Modeling (Distributions)\n\"]\n    A6[\"Web Application Interface (Streamlit)\n\"]\n    A7[\"Results Processing & Visualization\n\"]\n    A0 -- \"Generates & Manages\" --&gt; A1\n    A0 -- \"Requests Allocation\" --&gt; A3\n    A0 -- \"Uses Timings/Distributions\" --&gt; A5\n    A3 -- \"Checks & Allocates\" --&gt; A2\n    A4 -- \"Executes Runs\" --&gt; A0\n    A4 -- \"Provides Raw Data\" --&gt; A7\n    A6 -- \"Configures & Initiates Runs\" --&gt; A4\n    A7 -- \"Provides Results/Visuals\" --&gt; A6\n\n\n\n\n\n\n\n\n\nWeb Application Interface (Streamlit)\nSimulation Engine (Patient Journey)\nPatient Entity\nHEMS Resource Entity\nResource Management (Availability & Allocation)\nStochastic Modeling (Distributions)\nSimulation Runner & Parallelization\nResults Processing & Visualization\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Tutorial: DAA_DES"
    ]
  },
  {
    "objectID": "index.html#chapters",
    "href": "index.html#chapters",
    "title": "Tutorial: DAA_DES",
    "section": "",
    "text": "Web Application Interface (Streamlit)\nSimulation Engine (Patient Journey)\nPatient Entity\nHEMS Resource Entity\nResource Management (Availability & Allocation)\nStochastic Modeling (Distributions)\nSimulation Runner & Parallelization\nResults Processing & Visualization\n\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Tutorial: DAA_DES"
    ]
  },
  {
    "objectID": "07_simulation_runner___parallelization_.html",
    "href": "07_simulation_runner___parallelization_.html",
    "title": "Chapter 7: Simulation Runner & Parallelization",
    "section": "",
    "text": "Chapter 7: Simulation Runner & Parallelization\nIn Chapter 6: Stochastic Modeling (Distributions), we learned how the simulation uses randomness (like rolling dice based on real data) to make things like activity times and patient arrivals realistic. But because of this randomness, running the simulation just once might give us an unusual result – maybe by pure chance, things went really smoothly, or maybe everything went wrong!\nHow can we be confident in the results? We need to run the simulation many times. But running a complex simulation hundreds of times could take hours or even days! This chapter introduces the Simulation Runner, the part of our project that handles actually executing the simulation, and its powerful feature: Parallelization, which helps us run multiple simulations much faster.\nWhat Problem Does This Solve?\nImagine you want to test the effect of adding a new response car. You run the simulation once for one simulated year. The result shows an average response time of 15 minutes. Is that good? Bad? Lucky? Unlucky? You don’t know from a single run.\nTo get a reliable answer, you need to run the simulation many times (say, 30 times) with the same settings. Each run is called a replication. By looking at the results across all 30 replications, you can calculate a trustworthy average response time and see how much it varied (the range of possible outcomes).\nBut running 30 year-long simulations one after another would be very slow. This is where the Simulation Runner and Parallelization come in:\n\nManages Execution: It provides functions to start and run the Simulation Engine (Patient Journey).\nHandles Replications: It allows you to easily specify how many times you want to run the simulation.\nSpeeds Things Up (Parallelization): It uses the power of modern computers (which often have multiple processing units or “cores”) to run several replications at the same time, drastically reducing the total waiting time.\nGathers Results: After all the runs are finished, it collects the results from each individual replication and combines them into a single dataset ready for analysis.\n\nAnalogy: Playing Many Games at Once\nThink of our simulation as a complex board game representing the HEMS service.\n\nSingle Run: Playing the game once to see the outcome.\nMultiple Replications: Playing the game 30 times, writing down the score each time. This gives you a better idea of the average score and the highest/lowest possible scores.\nSimulation Runner: The person (or program) responsible for setting up the board, playing the game according to the rules, and recording the score.\nParallelization: Instead of playing one game at a time, imagine having a room full of identical game boards and players. You tell them all to start playing simultaneously. If you have 4 sets of players, you can finish 4 games in the time it used to take to finish one! The Simulation Runner acts like the coordinator, starting all the games and collecting the scores when they’re done.\n\nHow You Use It (via the Web App)\nYou typically don’t interact with the Simulation Runner code directly. Instead, you use the controls provided in the Web Application Interface (Streamlit).\nRemember from Chapter 1, on the “Run Simulation” page (app/model.py), you have inputs like:\n\nNumber of Runs: This tells the Simulation Runner how many replications to perform.\nSimulation Duration: How long each simulation run should last (e.g., 365 days).\nThe main “Run Simulation” button.\n\nWhen you click the button, the Streamlit app calls functions from the des_parallel_process.py file.\n# In app/model.py (simplified example from Chapter 1)\nimport streamlit as st\n# Import simulation runner functions\nfrom des_parallel_process import runSim, parallelProcessJoblib, collateRunResults\n\n# Create a button\nbutton_run_pressed = st.button(\"Click to run the simulation\")\n\n# Check if the button was clicked\nif button_run_pressed:\n    st.info(\"Simulation started... please wait.\")\n    # Retrieve parameters the user set\n    num_runs = st.session_state.number_of_runs_input # How many replications?\n    sim_days = st.session_state.sim_duration_input\n    # ... other parameters ...\n\n    # If running locally (with multiple CPU cores)...\n    # Use the parallel runner\n    parallelProcessJoblib(\n        total_runs=num_runs,\n        sim_duration=float(sim_days * 24 * 60), # Convert days to minutes\n        # ... pass other parameters ...\n    )\n    # After all parallel runs finish, gather the results\n    collateRunResults()\n\n    st.success(\"Simulation complete! View results below.\")\n    # Code to load results and display them follows...\nExplanation:\n\nWhen the button is pressed, the code gets the num_runs value you selected.\nIt calls parallelProcessJoblib, telling it how many runs to perform and passing the simulation settings. This function manages the parallel execution.\nparallelProcessJoblib runs the simulation num_runs times, potentially using multiple CPU cores simultaneously. Each run saves its results to a temporary file.\nOnce all runs managed by parallelProcessJoblib are complete, collateRunResults is called to merge all the temporary result files into one final file (usually data/run_results.csv).\nThe Streamlit app then loads this final file to show you the combined results.\n\n(Note: The code also includes logic to run simulations sequentially (runSim in a loop) if parallel processing isn’t available, like on some web hosting platforms.)\nUnder the Hood: How Parallel Runs Work\nLet’s trace what happens when you click “Run Simulation” for 4 replications on a computer with multiple cores:\n\nTrigger: The Streamlit app calls parallelProcessJoblib(total_runs=4, ...) in des_parallel_process.py.\nSeed Generation: The runner generates a list of unique starting “random seeds” (like different starting hands in a card game) for each replication. This ensures that although each run uses randomness (Stochastic Modeling (Distributions)), the overall set of runs is reproducible if you use the same master seed again.\nTask Distribution: The runner uses a library called joblib. It creates 4 separate “jobs”, one for each replication. Each job is essentially a command: “Run the simulation once (runSim) with these parameters and this specific random seed”.\nParallel Execution: joblib assigns these jobs to available CPU cores. If your computer has 4 cores, all 4 replications might start running at roughly the same time.\n\nCore 1 runs Replication #1 (runSim(run=0, random_seed=seed1, ...)).\nCore 2 runs Replication #2 (runSim(run=1, random_seed=seed2, ...)).\nCore 3 runs Replication #3 (runSim(run=2, random_seed=seed3, ...)).\nCore 4 runs Replication #4 (runSim(run=3, random_seed=seed4, ...)).\n\nIndividual Run: Inside each runSim call:\n\nA new Simulation Engine (Patient Journey) instance is created with the specific parameters and seed.\nThe simulation engine runs through the entire patient journey logic, generating calls, assigning resources (Resource Management (Availability & Allocation)), and tracking patients (Patient Entity) and resources (HEMS Resource Entity).\nAt the end of the run, runSim saves the results (the detailed event log) for that specific replication to a temporary file like data/output_run_0.csv, data/output_run_1.csv, etc.\n\nWaiting: parallelProcessJoblib waits until all 4 jobs have finished and saved their temporary files.\nCollation: The Streamlit app then calls collateRunResults().\n\nThis function finds all files matching data/output_run_*.csv.\nIt reads each file into memory.\nIt combines them into one large table (DataFrame).\nIt saves this combined table to data/run_results.csv.\nIt deletes the temporary output_run_*.csv files.\n\nResults Display: The Streamlit app reads data/run_results.csv and displays the aggregated results and visualizations.\n\nSimplified Diagram:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant App as Streamlit App (app/model.py)\n    participant Runner as Parallel Runner (parallelProcessJoblib)\n    participant Core1 as CPU Core 1\n    participant Core2 as CPU Core 2\n    participant Collator as Result Collator (collateRunResults)\n\n    User-&gt;&gt;App: Set Number of Runs (e.g., 2), Click Run\n    App-&gt;&gt;Runner: parallelProcessJoblib(total_runs=2, ...)\n    Runner-&gt;&gt;Runner: Generate unique seeds (seed1, seed2)\n    Runner-)Core1: Assign Job 1: runSim(run=0, seed=seed1, ...)\n    Runner-)Core2: Assign Job 2: runSim(run=1, seed=seed2, ...)\n    Note over Core1, Core2: Both runSim execute simultaneously\n    Core1--&gt;&gt;Runner: Run 0 finished, saved output_run_0.csv\n    Core2--&gt;&gt;Runner: Run 1 finished, saved output_run_1.csv\n    Runner--&gt;&gt;App: All parallel runs complete\n    App-&gt;&gt;Collator: collateRunResults()\n    Collator-&gt;&gt;Collator: Find output_run_0.csv, output_run_1.csv\n    Collator-&gt;&gt;Collator: Combine into run_results.csv\n    Collator-&gt;&gt;Collator: Delete temporary files\n    Collator--&gt;&gt;App: Collation complete\n    App-&gt;&gt;User: Display results from run_results.csv\n\n\n\n\n\n\nCode Glimpses (des_parallel_process.py)\nLet’s look at the key functions involved:\n\nrunSim: Executes a single simulation replication.\n# In des_parallel_process.py (Simplified)\nimport time\nimport pandas as pd\nfrom des_hems import DES_HEMS # The main simulation engine class\nfrom utils import Utils # Utility functions\n\ndef runSim(run: int, total_runs: int, sim_duration: int, ..., random_seed: int):\n    \"\"\"Runs one replication of the simulation.\"\"\"\n    print(f\"{Utils.current_time()}: Starting Run {run+1} of {total_runs} with seed {random_seed}\")\n    start_time = time.process_time()\n\n    # 1. Create a simulation model instance for this specific run\n    #    Pass the unique random_seed to ensure it behaves independently\n    daa_model = DES_HEMS(\n        run_number=run,\n        sim_duration=sim_duration,\n        random_seed=random_seed, # Use the specific seed for this run\n        # ... other parameters ...\n    )\n\n    # 2. Execute the simulation engine's main run process\n    daa_model.run()\n\n    # 3. Get the results DataFrame from the model instance\n    results_df = daa_model.results_df\n\n    # 4. Save this run's results to a temporary, unique file\n    output_filename = os.path.join(Utils.RESULTS_FOLDER, f\"output_run_{run}.csv\")\n    results_df.to_csv(output_filename, index=False)\n\n    print(f\"Run {run+1} finished in {time.process_time() - start_time:.2f}s\")\n    # This function implicitly returns when done (or could return results_df)\nparallelProcessJoblib: Manages running runSim multiple times in parallel.\n# In des_parallel_process.py (Simplified)\nfrom joblib import Parallel, delayed\nfrom numpy.random import SeedSequence # For generating good random seeds\n\ndef parallelProcessJoblib(total_runs: int, sim_duration: int, ..., master_seed=42, n_cores=-1):\n    \"\"\"Executes multiple simulation runs in parallel using joblib.\"\"\"\n\n    # 1. Generate a list of unique, independent seeds for each run\n    #    Derived from the master_seed for reproducibility.\n    seed_sequence = SeedSequence(master_seed).spawn(total_runs)\n    run_seeds = [s.generate_state(1)[0] for s in seed_sequence]\n\n    print(f\"Starting {total_runs} runs in parallel using {n_cores} cores...\")\n\n    # 2. Use joblib's Parallel and delayed functions\n    #    This tells joblib to call 'runSim' for each run number from 0 to total_runs-1\n    #    It automatically distributes these calls across 'n_cores' CPUs.\n    Parallel(n_jobs=n_cores)(\n        delayed(runSim)(\n            run=i, # The current run number (0, 1, 2, ...)\n            total_runs=total_runs,\n            sim_duration=sim_duration,\n            random_seed=run_seeds[i], # Pass the unique seed for this run\n            # ... pass other parameters ...\n        )\n        for i in range(total_runs) # Loop through the number of replications\n    )\n    print(\"All parallel runs completed.\")\n    # This function finishes when all the 'delayed(runSim)' calls are done.\ncollateRunResults: Gathers the results from the temporary files.\n# In des_parallel_process.py (Simplified)\nimport glob # For finding files matching a pattern\nimport os\nimport pandas as pd\nfrom utils import Utils\n\ndef collateRunResults() -&gt; None:\n    \"\"\"Collates results from temporary run files into a single CSV.\"\"\"\n    print(\"Collating results...\")\n    # 1. Find all files starting with \"output_run_\" in the results folder\n    temp_files_pattern = os.path.join(Utils.RESULTS_FOLDER, \"output_run_*.csv\")\n    temp_files = glob.glob(temp_files_pattern)\n\n    if not temp_files:\n        print(\"No temporary result files found.\")\n        return\n\n    # 2. Read each temporary file into a pandas DataFrame and store in a list\n    list_of_dfs = [pd.read_csv(f) for f in temp_files]\n\n    # 3. Concatenate (stack) all these DataFrames into one big DataFrame\n    combined_df = pd.concat(list_of_dfs, ignore_index=True)\n\n    # 4. Save the combined DataFrame to the final results file\n    final_output_path = Utils.RUN_RESULTS_CSV # e.g., \"data/run_results.csv\"\n    combined_df.to_csv(final_output_path, index=False)\n    print(f\"Combined results saved to {final_output_path}\")\n\n    # 5. Clean up: Delete the temporary files\n    for f in temp_files:\n        os.remove(f)\n    print(\"Temporary files removed.\")\n\nConclusion\nThe Simulation Runner is the mechanism that actually executes our simulation model. Because our model includes randomness (Stochastic Modeling (Distributions)), running it just once isn’t enough. The runner allows us to perform multiple replications.\nCrucially, it supports parallelization, using joblib to run many replications simultaneously on different CPU cores. This dramatically speeds up the process of gathering enough data for reliable analysis. Finally, helper functions like collateRunResults merge the outputs from all these parallel runs into a single, tidy dataset.\nNow that we have this combined dataset containing results from potentially many simulation runs, how do we make sense of it all? How do we calculate key metrics and create informative charts? That’s the focus of our final chapter.\nNext: Chapter 8: Results Processing & Visualization\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Components",
      "Chapter 7: Simulation Runner & Parallelization"
    ]
  },
  {
    "objectID": "05_resource_management__availability___allocation__.html",
    "href": "05_resource_management__availability___allocation__.html",
    "title": "Chapter 5: Resource Management (Availability & Allocation)",
    "section": "",
    "text": "Chapter 5: Resource Management (Availability & Allocation)\nIn Chapter 4: HEMS Resource Entity, we learned about the digital profiles representing each helicopter and car in the simulation – the “players” on our team. But how does the simulation decide which player to send when an emergency call comes in? And how does it know if they are even available?\nThat’s where Resource Management comes in. Think of this part of the simulation as the Dispatch Center or the Air Traffic Controller for our HEMS (Helicopter Emergency Medical Service) units. It keeps track of every resource, knows who is working, who is busy, and who is best suited for the next job.\nWhat Problem Does This Solve?\nImagine a 999 call comes in: a serious accident requiring Critical Care (CC). The DAA has several resources: a CC helicopter (H70), an EC (Emergency Care) helicopter (H71), and a CC car (CC72).\n\nWhich one should go? (Probably the CC helicopter, H70, is preferred).\nIs H70 actually working right now (on shift)?\nIs H70 already busy helping someone else?\nIs H70 in the hangar for maintenance?\nIf H70 isn’t available, what’s the next best option? (Maybe the CC car, CC72?).\n\nWithout a central system managing this, the simulation would be chaos! Resources might get double-booked, or the wrong type of help might be sent. The Resource Management system solves this by acting as the central coordinator for all HEMS resources.\nMeet the Dispatch Center: Key Roles\nThe Resource Management system, primarily implemented in the class_hems_availability.py file, acts like a dispatcher with a real-time status board. Its main jobs are:\n\nTracking Availability: It constantly knows the status of each HEMS Resource Entity.\n\nOn Shift? Is the resource scheduled to work at this specific simulation time (based on its rota)?\nBusy? Is it currently assigned to another patient (in_use flag)?\nUnder Maintenance? Is it unavailable due to scheduled servicing (being_serviced flag)?\n\nDetermining Preference: When a Patient Entity needs help, the system looks at the patient’s needs (e.g., requires ‘CC’ level care) and compares them against the available resources. It uses built-in rules (a hierarchy) to decide which type of resource is preferred. For example:\n\nFor a CC patient, a CC Helicopter is usually preferred over a CC Car.\nA CC Car might be preferred over an EC Helicopter (depending on the specific rules).\n\nAllocation: If a suitable and available resource is found based on the preference rules, the system “allocates” or assigns it to the patient.\n\nIt marks the resource as in_use = True.\nIt records which resource was assigned to the patient.\n\nHandling Unavailability: If the preferred resource isn’t available, it checks the next best option according to the hierarchy. If no suitable resource is available at all, it records that HEMS could not respond.\nRelease: Once a resource finishes its task (e.g., patient delivered to hospital, returned to base), the system marks it as available again (in_use = False) so it can be dispatched to the next call.\n\nHow the Simulation Engine Uses Resource Management\nRemember the Simulation Engine (Patient Journey)? When it creates a new patient, it needs to ask the Resource Management system if help is available.\nThis happens inside the generate_patient function in des_hems.py:\n# In des_hems.py (simplified 'generate_patient' function)\n\n# ... patient 'pt' is created and details like pt.hems_cc_or_ec are set ...\n\n# Ask Resource Management (self.hems_resources) for a resource\n# The type of allocation function depends on the patient's needs (REG vs CC/EC)\nif pt.hems_cc_or_ec == 'REG':\n    # Ask for a resource suitable for a 'Regular' case\n    hems_res_list: list = yield self.hems_resources.allocate_regular_resource(pt)\nelse:\n    # Ask for a resource suitable for a 'CC' or 'EC' case\n    hems_res_list: list = yield self.hems_resources.allocate_resource(pt)\n\n# The result is a list: [Allocated HEMS Resource object or None, reason_code, secondary_resource or None]\nhems_allocation = hems_res_list[0] # The main HEMS object if allocated, otherwise None\nallocation_reason = hems_res_list[1] # Text describing why this resource was chosen (or why none)\n\n# Add the reason to our results log\nself.add_patient_result_row(pt, allocation_reason, \"resource_preferred_outcome\")\n\nif hems_allocation is not None:\n    # SUCCESS! A resource was found. Start the patient's journey.\n    self.env.process(self.patient_journey(hems_allocation, pt, hems_res_list[2]))\n    # Record which resource was used\n    self.add_patient_result_row(pt, hems_allocation.callsign, \"resource_use\")\nelse:\n    # FAILURE! No suitable HEMS resource was available right now.\n    self.add_patient_result_row(pt, \"No HEMS available\", \"queue\")\n    # The patient journey might proceed differently (e.g., handled by land ambulance only)\n    # In this simplified example, we might just end their journey here.\nExplanation:\n\nThe code first determines if the patient needs ‘REG’ care or higher (‘CC’/‘EC’).\nIt then calls the appropriate function from the self.hems_resources object (which is an instance of the HEMSAvailability class from class_hems_availability.py). It passes the pt (Patient Entity) object, which contains the patient’s needs.\nThe yield keyword pauses the patient’s process while Resource Management figures out the allocation.\nResource Management returns a list (hems_res_list). The most important part is the first item (hems_allocation):\n\nIf it’s a HEMS Resource Entity object (like the profile for H70), it means a resource was successfully assigned.\nIf it’s None, it means no suitable resource was free.\n\nThe code then proceeds based on whether a resource was allocated or not.\n\nUnder the Hood: The Dispatcher’s Logic (HEMSAvailability class)\nLet’s peek inside the class_hems_availability.py file, where the HEMSAvailability class lives. This class manages the pool of resources.\n1. Initialization and Resource Pool: When the simulation starts, HEMSAvailability reads the resource details (from files like HEMS_ROTA.csv) and creates a HEMS Resource Entity object for each one. It also calculates their maintenance schedules. These objects are stored in a special container called a simpy.FilterStore. Think of this store as the dispatcher’s cabinet holding all the resource files.\n# In class_hems_availability.py (Simplified __init__ and prep_HEMS_resources)\nimport simpy\nimport pandas as pd\nfrom class_hems import HEMS # The blueprint for a resource\n\nclass HEMSAvailability():\n    def __init__(self, env, sim_start_date, ...):\n        self.env = env # The simulation environment\n        self.store = simpy.FilterStore(env) # The 'cabinet' for resources\n        self.serviceStore = simpy.FilterStore(env) # A separate cabinet for resources being serviced\n        self.HEMS_resources_list = [] # Temporary list to hold resources before putting in store\n        self.active_callsign_groups = set() # Track busy crews\n        self.active_registrations = set() # Track busy vehicles\n        self.active_callsigns = set() # Track busy callsigns\n\n        # Read data and create resource objects\n        self.prep_HEMS_resources()\n        # Put the created resource objects into the main store\n        self.populate_store()\n        # Perform initial check for servicing\n        # ... daily servicing check setup ...\n\n    def prep_HEMS_resources(self):\n        # Read HEMS details from CSV files (Rotas, Registrations, Servicing rules)\n        HEMS_RESOURCES_DATA = pd.read_csv(\"actual_data/HEMS_ROTA.csv\")\n        # ... merge with other data like servicing history ...\n\n        # Loop through each resource defined in the data\n        for index, row in HEMS_RESOURCES_DATA.iterrows():\n            # Calculate the specific maintenance schedule for this vehicle\n            service_df = self.calculate_service_dates(row['registration'], ...) # Complex logic here\n\n            # Create a HEMS object using the blueprint\n            hems_object = HEMS(\n                callsign=row['callsign'],\n                vehicle_type=row['vehicle_type'],\n                category=row['category'],\n                # ... other details like rota times ...\n                servicing_schedule=service_df # Attach the calculated schedule\n            )\n            # Add the new resource object to our list\n            self.HEMS_resources_list.append(hems_object)\n\n    def populate_store(self):\n        # Put each created HEMS object into the SimPy store\n        for h in self.HEMS_resources_list:\n            self.store.put(h)\n2. Checking Availability and Preference (preferred_resource_available): This is the core logic for finding the best match. It loops through the resources in the store and checks their status and capabilities against the patient’s needs.\n# In class_hems_availability.py (Simplified preferred_resource_available for CC/EC)\n\n    def preferred_resource_available(self, pt: Patient) -&gt; list:\n        hems: HEMS | None = None # Placeholder for the best resource found\n        preferred = 999 # Lower number is better preference (1 = best)\n        preferred_lookup = 0 # Code indicating which rule matched\n\n        preferred_care_category = pt.hems_cc_or_ec # e.g., 'CC'\n\n        # Look through all resources currently in the main store (not busy, not servicing)\n        h: HEMS\n        for h in self.store.items:\n            # --- Basic Availability Checks ---\n            # Is the resource currently marked as busy?\n            # Is the crew already assigned to another task? (Check active sets)\n            # Is the vehicle already assigned? (Check active sets)\n            # Is it actually scheduled to be working now?\n            if (h.in_use or\n                h.callsign_group in self.active_callsign_groups or\n                h.registration in self.active_registrations or\n                not h.hems_resource_on_shift(pt.hour, pt.qtr)\n                # NOTE: Servicing check happens daily, moving resources to serviceStore\n               ):\n                continue # Skip this resource, it's not available\n\n            # --- Preference Logic (Example for CC/EC) ---\n            # Rule 1: Preferred care category & Helicopter? (BEST)\n            if h.category == preferred_care_category and h.vehicle_type == \"helicopter\":\n                hems = h\n                preferred = 1\n                preferred_lookup = 1\n                return [hems, self.resource_allocation_lookup(preferred_lookup)] # Found best, stop searching\n\n            # Rule 2: Preferred care category & Car? (Good)\n            elif h.category == preferred_care_category: # Vehicle type must be Car\n                if preferred &gt; 2: # If we haven't found a better match yet\n                    hems = h\n                    preferred = 2\n                    preferred_lookup = 2\n\n            # Rule 3/4: If patient needs CC, is an EC resource available?\n            elif preferred_care_category == 'CC':\n                if h.category == 'EC' and h.vehicle_type == 'helicopter':\n                   if preferred &gt; 3: hems = h; preferred = 3; preferred_lookup = 3\n                elif h.category == 'EC': # Must be Car\n                   if preferred &gt; 4: hems = h; preferred = 4; preferred_lookup = 4\n\n            # Rule 5/6: If patient needs EC, is a CC resource available? (Similar logic)\n            # ...\n\n        # After checking all resources, return the best one found (or None)\n        if hems is not None:\n            return [hems, self.resource_allocation_lookup(preferred_lookup)]\n        else:\n            return [None, self.resource_allocation_lookup(0)] # Code 0 = No resource available\n3. Allocating the Resource (allocate_resource): Once the preferred available resource is identified, this function attempts to “take” it from the store and mark it as busy. It uses SimPy’s store.get() mechanism.\n# In class_hems_availability.py (Simplified allocate_resource for CC/EC)\n\n    def allocate_resource(self, pt: Patient):\n        resource_event = self.env.event() # SimPy event to signal completion\n\n        def process(): # Inner function to handle the allocation steps\n            # 1. Find the best available resource using the logic above\n            pref_res: list = self.preferred_resource_available(pt)\n            primary_resource = pref_res[0] # The HEMS object or None\n            reason = pref_res[1] # The reason code\n\n            if primary_resource is None:\n                # No resource found, signal failure immediately\n                return resource_event.succeed([None, reason, None])\n\n            # 2. Try to 'get' the chosen resource from the store\n            # This ensures only one process gets it at a time\n            with self.store.get(lambda r: r == primary_resource) as request:\n                result = yield request | self.env.timeout(0.1) # Wait briefly if needed\n\n                if request in result:\n                    # SUCCESS: We got the resource!\n                    primary_resource.in_use = True # Mark it as busy\n                    # Add identifiers to sets tracking active resources\n                    self.active_callsign_groups.add(primary_resource.callsign_group)\n                    self.active_registrations.add(primary_resource.registration)\n                    self.active_callsigns.add(primary_resource.callsign)\n\n                    # Store details in patient object\n                    pt.hems_callsign_group = primary_resource.callsign_group\n                    # ... store other details ...\n\n                    # (Logic to find a secondary resource like a car if needed is omitted for simplicity)\n                    secondary_resource = None\n\n                    # Signal success, returning the allocated resource\n                    return resource_event.succeed([primary_resource, reason, secondary_resource])\n                else:\n                    # FAILURE: Couldn't get the resource (maybe taken by another process?)\n                    # Signal failure\n                    return resource_event.succeed([None, reason, None])\n\n        self.env.process(process()) # Start the allocation process\n        return resource_event # Return the event that will eventually hold the result\n4. Releasing the Resource (return_resource): When the patient_journey function in des_hems.py finishes, it calls this function to put the resource back into the available pool.\n# In class_hems_availability.py (Simplified return_resource)\n\n    def return_resource(self, resource: HEMS, secondary_resource: HEMS | None):\n        # Mark the primary resource as not busy\n        resource.in_use = False\n        # Remove identifiers from the active sets\n        self.active_callsign_groups.discard(resource.callsign_group)\n        self.active_registrations.discard(resource.registration)\n        self.active_callsigns.discard(resource.callsign)\n        # Put the resource object back into the main store\n        self.store.put(resource)\n\n        # (Repeat for secondary resource if applicable)\n        if secondary_resource is not None:\n             secondary_resource.in_use = False\n             # ... remove from active sets ...\n             self.store.put(secondary_resource)\nSimplified Allocation Flow Diagram:\n\n\n\n\n\nsequenceDiagram\n    participant Engine as Simulation Engine (des_hems.py)\n    participant ResMgmt as Resource Management (HEMSAvailability)\n    participant Store as SimPy FilterStore\n    participant H70 as HEMS Resource (in Store)\n\n    Engine-&gt;&gt;+ResMgmt: allocate_resource(Patient needing 'CC')\n    ResMgmt-&gt;&gt;ResMgmt: preferred_resource_available(Patient) finds H70 is best\n    ResMgmt-&gt;&gt;+Store: Get H70 resource object\n    Store--&gt;&gt;-ResMgmt: Provide H70 object\n    ResMgmt-&gt;&gt;H70: Set in_use = True\n    ResMgmt-&gt;&gt;ResMgmt: Add H70 details to active sets\n    ResMgmt--&gt;&gt;-Engine: Return H70 object (Success)\n\n    Note over Engine, H70: Patient Journey Simulation...\n\n    Engine-&gt;&gt;+ResMgmt: return_resource(H70)\n    ResMgmt-&gt;&gt;H70: Set in_use = False\n    ResMgmt-&gt;&gt;ResMgmt: Remove H70 details from active sets\n    ResMgmt-&gt;&gt;+Store: Put H70 resource object back\n    Store--&gt;&gt;-ResMgmt: Acknowledge return\n    ResMgmt--&gt;&gt;-Engine: Resource returned\n\n\n\n\n\n\nConclusion\nThe Resource Management system (HEMSAvailability) is the crucial dispatch center of our simulation. It maintains a real-time view of all HEMS Resource Entities, checking if they are on shift, free, and not under maintenance. When a Patient Entity needs help, it uses a defined hierarchy to select the preferred available resource, allocates it, and ensures it’s properly released afterwards. This prevents conflicts and ensures the simulation realistically models how resources are assigned based on availability and operational rules.\nBut how does the simulation decide how long each step takes (like mobilisation time or time on scene)? And how does it determine patient characteristics like age or the type of emergency? These aren’t fixed numbers; they involve randomness and probability. That’s what we’ll explore next.\nNext: Chapter 6: Stochastic Modeling (Distributions)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Components",
      "Chapter 5: Resource Management (Availability & Allocation)"
    ]
  },
  {
    "objectID": "03_patient_entity_.html",
    "href": "03_patient_entity_.html",
    "title": "Chapter 3: Patient Entity",
    "section": "",
    "text": "Chapter 3: Patient Entity\nIn Chapter 2: Simulation Engine (Patient Journey), we learned about the “director” of our simulation – the engine that manages the flow of events and time. Now, let’s meet the main “actor” in our simulation play: the Patient Entity.\nWhat’s the Point of a Patient Entity?\nImagine our simulation is like a board game simulating the Devon Air Ambulance service. Each time an emergency call comes in, we need a game piece to represent that specific incident. This piece needs to move around the board (representing the stages of care) and collect properties (like how serious the incident is, the patient’s age, and what happened to them).\nWithout a way to track each individual case, we couldn’t simulate the service realistically. We wouldn’t know how many people needed help, what kind of help they needed, or whether the service was able to respond effectively to each specific situation.\nThe Patient Entity solves this by acting as that unique game piece. It’s a digital representation of a single emergency incident requiring potential HEMS (Helicopter Emergency Medical Service) attention.\nMeet the Patient Entity: A Digital Case File\nThink of the Patient Entity as a digital file folder or a character sheet for each specific emergency case in the simulation. It doesn’t do things on its own, but it holds all the important information about one particular incident and the person involved.\nThe Simulation Engine (Patient Journey) creates a new Patient Entity whenever a simulated emergency call occurs. It then fills in and updates the information in this “folder” as the simulated incident progresses.\nWhat Information Does a Patient Entity Hold? (Its Attributes)\nOur Patient Entity “folder” contains several key pieces of information, just like our game piece collects properties:\n\nUnique ID (id): Just like each game piece might have a number, each Patient Entity gets a unique identification number (e.g., Patient 1, Patient 2, … Patient 5432). This helps us track each case separately.\nArrival Time (timestamp when event_type is ‘arrival’): When did the call for this patient come into the simulation? This is recorded as the simulation time (e.g., 125.5 minutes into the simulation).\nMedical Need:\n\nAMPDS Code (ampds_card): A code representing the type of emergency reported by the caller (e.g., “Chest Pain,” “Traffic Accident”). The simulation assigns this based on probabilities (Stochastic Modeling (Distributions)).\nCare Category (hems_cc_or_ec): Based on the AMPDS code and other factors, the simulation decides if the patient likely needs Critical Care (‘CC’), Emergency Care (‘EC’), or Regular (‘REG’) care from the HEMS team.\n\nDemographics:\n\nAge (age): The simulated age of the patient.\nSex (sex): The simulated sex of the patient (‘male’ or ‘female’). These are assigned based on patterns observed in real data (Stochastic Modeling (Distributions)).\n\nJourney Tracking & Outcomes:\n\nJourney Stages: The “folder” keeps track of when key events happened for this patient (e.g., when HEMS was assigned, when they arrived at the scene, when they left the scene).\nHEMS Result (hems_result): What happened with the HEMS response? (e.g., “Patient Conveyed,” “Stand Down En Route,” “Landed but no patient contact”).\nFinal Outcome (pt_outcome): What was the ultimate outcome for this specific simulated case? (e.g., “Airlifted,” “Conveyed by land with DAA,” “Deceased”).\nAssigned Resource (callsign, registration): If a HEMS resource was assigned, which one was it? (e.g., Helicopter G-DAAN). This links the patient to a specific HEMS Resource Entity.\n\n\nHow the Simulation Uses the Patient Entity\nThe Simulation Engine (Patient Journey) is the one that interacts with the Patient Entity.\n\nCreation: When the engine decides a new call occurs, it creates a brand new, empty Patient Entity object. python     # In des_hems.py (simplified 'generate_patient' function)     # ... inside the function when a new call happens ...     self.patient_counter += 1     # Create a new Patient object, giving it a unique ID     pt = Patient(self.patient_counter)     # Now 'pt' is our new, mostly empty, patient folder This code snippet, found within the generate_patient function in des_hems.py, shows the creation of a new Patient instance (pt) using the Patient class definition (which we’ll look at next).\nFilling Details: The engine then uses functions (often relying on Stochastic Modeling (Distributions)) to fill in the initial details.\n# In des_hems.py (simplified 'generate_patient' function)\n# Assign details to the 'pt' object\npt.hour = hod # Hour the call arrived\npt.ampds_card = self.utils.ampds_code_selection(pt.hour) # Assign medical code\npt.age = self.utils.age_sampling(pt.ampds_card, 115) # Assign age\npt.sex = self.utils.sex_selection(pt.ampds_card) # Assign sex\npt.hems_cc_or_ec = self.utils.care_category_selection(pt.ampds_card) # Assign care need\n# ... other initial details ...\n\n# Record the arrival event in the results log\nself.add_patient_result_row(pt, \"arrival\", \"arrival_departure\")\nHere, the engine calls utility functions (self.utils...) to determine things like the medical code (ampds_card) and demographics (age, sex) and stores them directly into the pt object’s attributes.\nUpdating During Journey: As the engine guides the patient through their simulated journey (mobilisation, travel, scene time, etc.), it updates the Patient Entity and records events.\n# In des_hems.py (simplified 'patient_journey' function)\n# ... after simulating mobilisation time ...\nmobilisation_time = self.utils.activity_time(patient.hems_vehicle_type, 'time_mobile')\nyield self.env.timeout(mobilisation_time) # Advance simulation clock\n\n# Record that the HEMS resource is now mobile for this patient\nself.add_patient_result_row(patient, \"HEMS mobile\", \"queue\")\n\n# ... later, after simulating travel time ...\ntts_time = self.utils.activity_time(patient.hems_vehicle_type, 'time_to_scene')\nyield self.env.timeout(tts_time) # Advance simulation clock\n\n# Record that HEMS is on scene for this patient\nself.add_patient_result_row(patient, \"HEMS on scene\", \"queue\")\nIn the patient_journey function, after simulating a time delay (yield self.env.timeout(...)), the engine calls self.add_patient_result_row(...). This function takes the patient object (our Patient Entity) and the event details (“HEMS mobile”, “HEMS on scene”) and logs them. This log file becomes the raw data for Results Processing & Visualization.\n\nUnder the Hood: The Patient Class\nThe blueprint for creating these Patient Entity “folders” is defined in a Python file called class_patient.py. This file contains a class named Patient. A class is like a template for creating objects.\n# In class_patient.py (Heavily Simplified Structure)\n\nclass Patient:\n    # The __init__ method is called when a new Patient object is created\n    def __init__(self, p_id: int):\n        # --- Core Identifiers ---\n        self.id = p_id          # Unique ID for this patient instance\n        self.time_in_sim = 0    # How long this patient has been in the sim (updated later)\n        self.current_dt = None  # The datetime the patient entered the sim (set later)\n\n        # --- Incident & Medical Details (Filled in by Simulation Engine) ---\n        self.ampds_card = \"\"    # e.g., \"17A1\" (Falls)\n        self.hems_cc_or_ec = \"REG\" # Care Category: 'CC', 'EC', or 'REG'\n        # ... other incident details like location (postcode, lat/long) ...\n\n        # --- Demographics (Filled in by Simulation Engine) ---\n        self.age = 0            # e.g., 65\n        self.sex = \"female\"     # e.g., \"male\" or \"female\"\n\n        # --- Journey & Outcome Tracking (Filled in by Simulation Engine) ---\n        self.hems_case = -1     # Is this potentially a HEMS case? (1=yes, 0=no)\n        self.hems_result = \"\"   # e.g., \"Patient Conveyed\", \"Stand Down En Route\"\n        self.pt_outcome = \"\"    # e.g., \"Airlifted\", \"Deceased\"\n        self.callsign = \"\"      # Callsign of assigned HEMS resource (e.g., \"H70\")\n        self.hems_vehicle_type = \"\" # e.g., \"Helicopter\", \"Car\"\n        # ... other tracking variables ...\n\n    # (The Patient class doesn't usually have many methods,\n    #  it mostly just holds data)\nWhen the line pt = Patient(self.patient_counter) runs in des_hems.py, Python uses this Patient class blueprint to create a new object in memory. This object starts with the default values shown above (like ampds_card = \"\", age = 0). The Simulation Engine (Patient Journey) then accesses and modifies these attributes (like pt.age = calculated_age) as the simulation progresses.\nConclusion\nThe Patient Entity is the fundamental unit representing an individual emergency case within the DAA_DES simulation. It acts like a digital file folder or a game piece, holding crucial information like the patient’s ID, medical needs, demographics, and the details of their journey through the HEMS system.\nWhile the Simulation Engine (Patient Journey) directs the action, the Patient Entity stores the state and characteristics of each case. Understanding this data container is key to seeing how the simulation tracks individual experiences and generates meaningful results.\nNow that we’ve met the patient, let’s look at the other crucial actors in our simulation: the emergency resources themselves.\nNext: Chapter 4: HEMS Resource Entity\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Components",
      "Chapter 3: Patient Entity"
    ]
  },
  {
    "objectID": "01_web_application_interface__streamlit__.html",
    "href": "01_web_application_interface__streamlit__.html",
    "title": "Chapter 1: Web Application Interface (Streamlit)",
    "section": "",
    "text": "Chapter 1: Web Application Interface (Streamlit)\nWelcome to the Devon Air Ambulance Discrete Event Simulation (DAA_DES) project! This project simulates how the Devon Air Ambulance service responds to calls. It’s a complex system, but we want everyone, even those who aren’t programmers, to be able to use it and understand its results.\nImagine you’re a manager at the air ambulance service. You might wonder, “What happens if we add an extra response car? Or change the helicopter shift times?” Answering these questions usually requires deep knowledge of the simulation code. That’s where our Web Application Interface comes in!\nThis chapter introduces the user-friendly interface built with a tool called Streamlit. Think of it as the dashboard and control panel for our simulation. It hides all the complicated Python code (the “engine”) and gives you simple controls like buttons, sliders, and text boxes to configure and run the simulation. It also displays the results clearly using charts and key numbers.\nWhat Problem Does This Solve?\nWithout a graphical interface, users would need to:\n\nOpen the Python code files.\nFind the specific lines of code for parameters like helicopter schedules or demand levels.\nModify the code directly (risking errors!).\nRun the simulation using command-line instructions.\nManually process the raw output data (often large CSV files) to create charts or calculate metrics.\n\nThis is time-consuming and requires programming skills. The Streamlit interface solves this by providing an easy-to-use web application accessible through your browser.\nMeet Streamlit: Your Simulation Control Panel\nStreamlit is a Python library that makes it incredibly easy to create web applications for data science and machine learning projects. For DAA_DES, we use it to build the interactive layer on top of the core simulation model.\nHere’s what the interface allows you to do:\n\nConfigure: Set up the simulation parameters.\n\nHow many helicopters and cars are available? (app/setup.py)\nWhat are their working hours (rotas)? (app/setup.py)\nHow many calls should the simulation generate (demand levels)? (app/setup.py)\nHow long should the simulation run (e.g., 1 year, 3 years)? (app/setup.py)\nWhen should the simulation start? (app/setup.py)\n\nRun: Start the simulation with your chosen settings. (app/model.py)\nView: See the results. (app/model.py)\n\nKey performance metrics (e.g., average response time, resource utilization).\nCharts showing trends (e.g., calls per month, jobs per hour).\nComparisons with historical data.\n\n\nUsing the Interface: A Quick Tour\nGetting the simulation running via the interface is straightforward:\n\nStart the App: Open your terminal or command prompt, navigate to the project’s root directory, and type: bash     streamlit run app/app.py This command tells Streamlit to run the main application file (app.py), which will then open a new tab in your web browser.\nSetup Parameters: Navigate to the “Choose Model Parameters” page (controlled by app/setup.py). Here you’ll find widgets like sliders and number inputs.\nExample: Setting the simulation duration using a slider in app/setup.py (simplified):\n# In app/setup.py (simplified)\nimport streamlit as st\n\n# Get the current value from session state or use a default\ndefault_duration = 365\ncurrent_duration = st.session_state.get('sim_duration_input', default_duration)\n\n# Create a slider widget\nsim_duration_input = st.slider(\n    \"Simulation Duration (days)\",\n    min_value=1,        # Minimum allowed value\n    max_value=365 * 3,  # Maximum allowed value (3 years)\n    value=current_duration, # The default/current value shown\n    key=\"key_sim_duration_input\" # Unique identifier\n)\n\n# When the user changes the slider, update the session state\nst.session_state.sim_duration_input = sim_duration_input\n\nst.write(f\"You selected {sim_duration_input} days.\")\nThis code creates an interactive slider. When you move it, Streamlit automatically updates the displayed value and stores your choice (sim_duration_input) so the simulation can use it later.\nRun the Simulation: Go to the “Run Simulation” page (controlled by app/model.py). Click the main button to start the simulation.\nExample: The run button in app/model.py (simplified):\n# In app/model.py (simplified)\nimport streamlit as st\n# Import simulation runner functions (explained in later chapters)\nfrom des_parallel_process import runSim, parallelProcessJoblib, collateRunResults\n\n# Create a button\nbutton_run_pressed = st.button(\n    \"Click to run the simulation\",\n    icon=\":material/play_circle:\"\n)\n\n# Check if the button was clicked\nif button_run_pressed:\n    st.info(\"Simulation started... please wait.\")\n    # Retrieve parameters the user set (from st.session_state)\n    num_runs = st.session_state.number_of_runs_input\n    sim_days = st.session_state.sim_duration_input\n    # ... retrieve other parameters ...\n\n    # Call the backend function to run the simulation\n    # (This function does the actual work, covered in Chapter 7)\n    parallelProcessJoblib(total_runs=num_runs, sim_duration=float(sim_days * 24 * 60))\n    collateRunResults() # Gathers results from runs\n\n    st.success(\"Simulation complete! View results below.\")\n    # Code to display results follows...\nWhen you click this button, the if button_run_pressed: block executes. It retrieves the parameters you set earlier and calls the core simulation functions (like parallelProcessJoblib).\nView Results: Once the simulation finishes, the app/model.py page will automatically update to show various tabs containing metrics, charts, and tables summarizing the outcomes.\nExample: Displaying a metric in app/model.py (simplified):\n# In app/model.py, after simulation runs (simplified)\nimport streamlit as st\nimport pandas as pd\nimport _app_utils # Our custom utility functions\n\n# Assume 'results_all_runs' DataFrame is loaded after simulation\n# results_all_runs = pd.read_csv(\"data/run_results.csv\")\n\n# Calculate a simple metric (e.g., average number of patients per run)\navg_patients = results_all_runs['P_ID'].nunique() / results_all_runs['run_number'].nunique()\n\n# Display the metric using Streamlit's st.metric function\nst.metric(\n    label=\"Average Patients per Run\",\n    value=f\"{avg_patients:.1f}\" # Format the number\n)\n\n# Display a chart (more details in Chapter 8)\n# fig = create_some_chart(results_all_runs) # Function to make a plot\n# st.plotly_chart(fig)\nThis uses Streamlit’s built-in functions (st.metric, st.plotly_chart) to present the simulation output in an easy-to-understand format.\n\nUnder the Hood: How Streamlit Connects Everything\nWhile you interact with the simple web page, Streamlit coordinates several actions behind the scenes when you click “Run Simulation”:\n\nInput Gathering: Streamlit reads the current values from all the widgets (sliders, number inputs, etc.) you configured on the setup.py page. These values are stored in Streamlit’s session state.\nFunction Call: The model.py script retrieves these parameters from the session state and passes them to the appropriate backend function, typically from des_parallel_process.py (Simulation Runner & Parallelization).\nSimulation Execution: The backend function runs the core Simulation Engine (Patient Journey), simulating patient arrivals, resource allocation, and outcomes based on the parameters.\nResults Generation: The simulation engine outputs raw data, usually saving it to CSV files (like run_results.csv).\nData Processing & Display: The model.py script then uses functions (often from visualisation scripts or covered in Results Processing & Visualization) to read these CSV files, calculate summary statistics, and create plots.\nUpdate Interface: Finally, Streamlit updates the web page to display these metrics and charts in the results tabs.\n\nHere’s a simplified diagram of the flow:\n\n\n\n\n\nsequenceDiagram\n    participant U as User\n    participant ST as Streamlit App (app/*.py)\n    participant SR as Simulation Runner (des_parallel_process.py)\n    participant SE as Simulation Engine (des_hems.py, etc.)\n    participant RP as Results Processing (visualisation/*)\n\n    U-&gt;&gt;ST: Adjust parameters (sliders, etc.)\n    ST-&gt;&gt;ST: Store parameters in session state\n    U-&gt;&gt;ST: Click \"Run Simulation\" button\n    ST-&gt;&gt;SR: Call run function with parameters\n    SR-&gt;&gt;SE: Initiate simulation runs\n    SE--&gt;&gt;SR: Execute simulation logic\n    SR-&gt;&gt;RP: Collate raw results (CSV)\n    RP--&gt;&gt;ST: Provide processed data/plots\n    ST-&gt;&gt;U: Display results (metrics, charts)\n\n\n\n\n\n\nThe key takeaway is that the Streamlit code in the app/ folder acts as a bridge between you (the user) and the complex simulation engine running in the background.\nConclusion\nThe Web Application Interface, built using Streamlit, is the friendly face of the DAA_DES project. It allows anyone to easily configure simulation parameters, run different scenarios, and visualize the results without needing to write or modify any Python code. It acts as the control panel, making the powerful simulation engine accessible.\nNow that you understand how to interact with the simulation through its interface, we’ll dive into the heart of the system in the next chapter. We’ll explore how the simulation actually models the journey of a patient from the initial call to the final outcome.\nNext: Chapter 2: Simulation Engine (Patient Journey)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Components",
      "Chapter 1: Web Application Interface (Streamlit)"
    ]
  },
  {
    "objectID": "02_simulation_engine__patient_journey__.html",
    "href": "02_simulation_engine__patient_journey__.html",
    "title": "Chapter 2: Simulation Engine (Patient Journey)",
    "section": "",
    "text": "Chapter 2: Simulation Engine (Patient Journey)\nIn Chapter 1: Web Application Interface (Streamlit), we saw the control panel that lets you configure and run the DAA_DES simulation. But what actually happens when you click that “Run Simulation” button? How does the simulation know what to do?\nThis chapter introduces the Simulation Engine, the heart of our simulation. Think of it as the director of a play. The play is the Devon Air Ambulance service operating over a period (like a year). The actors are the individual patient cases that arise. The Simulation Engine directs each patient actor through their scenes (the stages of their interaction with the service), making sure everything happens in the right order and according to the rules.\nWhat Problem Does This Solve?\nImagine trying to manually figure out the entire sequence of events for thousands of potential emergency calls over a year. When does a call come in? Is a helicopter needed? Is one available? How long does it take to get ready, fly to the scene, treat the patient, fly to the hospital, and become ready again? This is incredibly complex!\nThe Simulation Engine automates this entire process. It manages the flow of time and events within the simulated world, allowing us to model the complex interactions between calls, resources, and patient outcomes.\nThe Director’s Script: Key Roles of the Engine\nThe Simulation Engine, primarily implemented in the des_hems.py file, handles several crucial tasks:\n\nGenerating Calls: It creates new patient incidents based on realistic patterns. For example, it knows that more calls tend to happen during certain hours of the day or certain times of the year. It uses probabilities (Stochastic Modeling (Distributions)) to decide when the next call arrives.\nAssessing the Situation: For each call, it determines the type of incident (based on simulated medical codes like AMPDS) and decides if a Helicopter Emergency Medical Service (HEMS) resource (like a helicopter or critical care car) is potentially needed.\nFinding Resources: If HEMS is needed, it checks if a suitable and available HEMS Resource Entity exists. This involves checking schedules (rotas), current status (is it already on a job? is it being serviced?), and rules for allocation (Resource Management (Availability & Allocation)).\nDirecting the Journey: If a resource is assigned, the engine guides the Patient Entity and the assigned resource through the key stages of the mission. It uses time delays (again, based on Stochastic Modeling (Distributions)) for each step:\n\nMobilisation: Time taken for the crew to get ready and depart.\nTravel to Scene: Time taken to fly or drive to the incident location.\nOn Scene: Time spent assessing and treating the patient.\nTravel to Hospital: Time taken to transport the patient (if needed).\nHandover: Time spent handing the patient over to hospital staff.\nClear: Time taken to become available for the next call (e.g., returning to base, refuelling).\n\nRecording Events: Throughout this journey, the engine logs every important event and timestamp. This data is crucial for later analysis (Results Processing & Visualization).\n\nA Patient’s Journey: An Example\nLet’s follow a simplified journey directed by the Simulation Engine:\n\nCall Arrives: The engine decides (based on its internal clock and probability distributions) that a call comes in at simulation time = 125.5 minutes.\nPatient Created: A new Patient Entity (let’s call them Patient 42) is created. The engine assigns them characteristics (like age, type of emergency - maybe a ‘CC’ or Critical Care case).\nResource Check: The engine asks the Resource Management (Availability & Allocation) system: “Is a Critical Care helicopter available?”\nResource Assigned: Let’s say Helicopter H70 is free. The engine assigns H70 to Patient 42.\nMobilisation: The engine looks up how long mobilisation usually takes (say, a random value like 5.2 minutes based on a distribution). It tells the simulation clock to advance by 5.2 minutes. simulation time = 130.7 minutes. H70 is now mobile.\nTravel to Scene: The engine determines travel time (e.g., 12.1 minutes). Clock advances. simulation time = 142.8 minutes. H70 arrives on scene.\nOn Scene: Engine determines time on scene (e.g., 25.6 minutes). Clock advances. simulation time = 168.4 minutes. H70 leaves the scene (perhaps flying to hospital).\n(…and so on for travel to hospital, handover, and becoming clear…)\nResource Freed: Once H70 completes its final step (e.g., returning to base), the engine tells the Resource Management (Availability & Allocation) system that H70 is available again.\n\nThe engine manages hundreds or thousands of these patient journeys simultaneously, making sure the shared resources (helicopters, cars) are used correctly and that time progresses logically.\nUnder the Hood: Code Glimpses\nThe core logic resides mainly in des_hems.py. We use a Python library called simpy to handle the simulation time and events.\n\nGenerating Calls (generate_calls in des_hems.py): This function runs continuously. It figures out when the next call should happen based on time-of-day patterns and random chance.\n# Simplified concept from des_hems.py\ndef generate_calls(self):\n    while self.env.now &lt; (self.sim_duration + self.warm_up_duration):\n        # 1. Figure out time until the next call based on distributions\n        time_to_next_call = self._calculate_interarrival_time() # Uses distributions\n\n        # 2. Tell simpy to pause (wait) for that duration\n        yield self.env.timeout(time_to_next_call)\n\n        # 3. Time's up! Create the patient process\n        # (Get details like day, hour, etc.)\n        dow, hod, _, month, qtr, dt = self.utils.date_time_of_call(...)\n        self.env.process(self.generate_patient(dow, hod, ..., dt))\nThe yield self.env.timeout(...) is simpy’s way of saying “pause this process and advance the simulation clock”. self.env.process(...) starts a new, independent process for the patient.\nCreating a Patient (generate_patient in des_hems.py): This function gets called by generate_calls. It sets up the patient’s details and tries to get a HEMS resource.\n# Simplified concept from des_hems.py\ndef generate_patient(self, dow, hod, ...):\n    self.patient_counter += 1\n    pt = Patient(self.patient_counter) # Create Patient object (Chapter 3)\n\n    # Assign details based on distributions (Chapter 6)\n    pt.hour = hod\n    pt.ampds_card = self.utils.ampds_code_selection(pt.hour)\n    pt.hems_cc_or_ec = self.utils.care_category_selection(pt.ampds_card)\n    # ... other patient details ...\n\n    # Record arrival event\n    self.add_patient_result_row(pt, \"arrival\", \"arrival_departure\")\n\n    # Ask Resource Management (Chapter 5) for a HEMS resource\n    # This uses the HEMSAvailability class (Chapter 5)\n    hems_res_list = yield self.hems_resources.allocate_resource(pt)\n    hems_allocation = hems_res_list[0] # The actual HEMS object or None\n\n    if hems_allocation is not None:\n        # If successful, start the main journey process\n        self.env.process(self.patient_journey(hems_allocation, pt, ...))\n    else:\n        # If no resource available, handle that (e.g., record it)\n        self.add_patient_result_row(pt, \"No HEMS available\", \"queue\")\nThis creates a Patient Entity, determines their needs, and interacts with the Resource Management (Availability & Allocation) system (self.hems_resources). If a resource is found, it kicks off the patient_journey.\nSimulating the Journey Steps (patient_journey in des_hems.py): This function simulates the time delays for each stage of the patient’s interaction.\n# Simplified concept from des_hems.py\ndef patient_journey(self, hems_res: HEMS, patient: Patient, ...):\n    try:\n        # --- Mobilisation Time ---\n        mobilisation_time = self.utils.activity_time(patient.hems_vehicle_type, 'time_mobile')\n        yield self.env.timeout(mobilisation_time) # Wait for mobilisation\n        self.add_patient_result_row(patient, \"HEMS mobile\", \"queue\") # Record event\n\n        # --- Time To Scene ---\n        tts_time = self.utils.activity_time(patient.hems_vehicle_type, 'time_to_scene')\n        yield self.env.timeout(tts_time) # Wait for travel\n        self.add_patient_result_row(patient, \"HEMS on scene\", \"queue\") # Record event\n\n        # --- Time On Scene ---\n        tos_time = self.utils.activity_time(patient.hems_vehicle_type, 'time_on_scene')\n        yield self.env.timeout(tos_time) # Wait while on scene\n        self.add_patient_result_row(patient, \"HEMS leaving scene\", \"queue\") # Record event\n\n        # ... other steps like travel to hospital, clear time ...\n\n    finally:\n        # --- Resource Becomes Free ---\n        # VERY important: tell Resource Management the resource is available again\n        if hems_res is not None:\n            self.hems_resources.return_resource(hems_res, ...)\n            self.add_patient_result_row(patient, hems_res.callsign, \"resource_use_end\")\nAgain, yield self.env.timeout(...) makes the simulation clock move forward. The self.add_patient_result_row(...) function logs what happened and when, building up the data needed for Results Processing & Visualization. The finally block ensures the resource is always returned.\n\nHow it Fits Together\nHere’s a simplified diagram showing the main interactions when a new call arrives:\n\n\n\n\n\nsequenceDiagram\n    participant GenCalls as generate_calls (Engine)\n    participant GenPat as generate_patient (Engine)\n    participant Pt as Patient Entity (Data)\n    participant ResMgmt as HEMSAvailability (Resource Logic)\n    participant Journey as patient_journey (Engine)\n\n    GenCalls-&gt;&gt;GenCalls: Calculate time to next call\n    GenCalls-&gt;&gt;+GenPat: Start new patient process()\n    GenPat-&gt;&gt;Pt: Create Patient()\n    GenPat-&gt;&gt;GenPat: Assign patient details (AMPDS, CC/EC)\n    GenPat-&gt;&gt;+ResMgmt: allocate_resource(patient)?\n    ResMgmt--&gt;&gt;-GenPat: Return HEMS Resource (or None)\n    alt Resource Available\n        GenPat-&gt;&gt;+Journey: Start patient_journey(HEMS, Patient)\n        Journey-&gt;&gt;Journey: yield timeout (mobilisation)\n        Journey-&gt;&gt;Journey: Record 'Mobile' event\n        Journey-&gt;&gt;Journey: yield timeout (travel to scene)\n        Journey-&gt;&gt;Journey: Record 'On Scene' event\n        Journey-&gt;&gt;Journey: ... other steps ...\n        Journey-&gt;&gt;-ResMgmt: return_resource(HEMS)\n    else No Resource Available\n        GenPat-&gt;&gt;GenPat: Record 'No HEMS' event\n    end\n\n\n\n\n\n\n\nThe Simulation Engine (des_hems.py containing generate_calls, generate_patient, patient_journey) acts as the central orchestrator. It creates patients, interacts with the resource management system, and steps through the time-based events of each patient’s journey, using data structures like the Patient Entity and rules defined in Resource Management (Availability & Allocation).\nConclusion\nThe Simulation Engine is the core logic that drives the DAA_DES simulation. It acts like a director, generating patient calls based on realistic patterns and guiding each patient (and the assigned HEMS resource) through the stages of their journey – from the initial call, through mobilisation, scene arrival, treatment, and finally becoming clear. It manages simulation time and ensures events happen in the correct sequence, using probabilistic timings defined in Stochastic Modeling (Distributions). This engine allows us to model the complex, dynamic behaviour of the HEMS system.\nNow that we understand how the overall flow is managed, let’s look more closely at the main ‘actor’ in our simulation: the patient.\nNext: Chapter 3: Patient Entity\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Components",
      "Chapter 2: Simulation Engine (Patient Journey)"
    ]
  },
  {
    "objectID": "04_hems_resource_entity_.html",
    "href": "04_hems_resource_entity_.html",
    "title": "Chapter 4: HEMS Resource Entity",
    "section": "",
    "text": "Chapter 4: HEMS Resource Entity\nIn Chapter 3: Patient Entity, we met the “actors” in our simulation – the digital representations of individual emergency cases. But who comes to help these patients? We need the emergency response units themselves!\nThis chapter introduces the HEMS Resource Entity. Think back to a city management game where you have fire trucks, police cars, and ambulances. Each vehicle is a distinct unit with its own capabilities, schedule, and status (available, busy, or in the garage). Our HEMS Resource Entity is just like that – it’s the digital version of a specific Devon Air Ambulance helicopter or response car.\nWhat Problem Does This Solve?\nImagine trying to run the simulation without knowing which helicopters or cars are available. How would we know if the right kind of help (e.g., a Critical Care team) is working at 2 AM? How would we know if Helicopter ‘H70’ is already busy helping another patient or if it’s grounded for maintenance?\nWe need a way to represent each operational unit individually, tracking its specific details and whether it’s ready to respond. The HEMS Resource Entity solves this by acting as a detailed profile for each vehicle in our simulated fleet.\nMeet the HEMS Resource Entity: A Vehicle’s Profile\nThe HEMS Resource Entity is essentially a digital “character sheet” for each helicopter and car available to the service. When the simulation starts, it creates these profiles based on real-world information about the fleet.\nThe Simulation Engine (Patient Journey) and, more specifically, the Resource Management (Availability & Allocation) system constantly consult these profiles to make decisions.\nWhat Information Does a Resource Entity Hold? (Its Attributes)\nEach HEMS Resource Entity “profile” stores key details:\n\nCallsign (callsign): A unique name for the resource, like “H70” (for a helicopter) or “CC72” (for a Critical Care car). Think of it as the vehicle’s radio name.\nVehicle Type (vehicle_type): Is it a “Helicopter” or a “Car”? This affects travel times and capabilities.\nCare Capability (category): What level of medical care can the crew provide? This is often ‘CC’ (Critical Care) or ‘EC’ (Emergency Care). This is like knowing if the vehicle has basic first aid or advanced life support equipment and staff.\nRegistration (registration): The unique physical identifier of the vehicle (like a license plate, e.g., “g-daan”). This is important for tracking maintenance.\nOperational Hours (Rotas): When is this specific resource scheduled to be active? This is defined by start and end times, which might differ between summer and winter.\n\nsummer_start, summer_end: Operating hours during summer months.\nwinter_start, winter_end: Operating hours during winter months.\n\nAvailability Status: This isn’t a single variable but determined by several factors checked by the simulation:\n\nIs it on shift right now? (Checked using the operational hours).\nIs it currently assigned to a task? (in_use): A flag (True/False) indicating if it’s busy with a patient.\nIs it undergoing maintenance? (being_serviced): A flag indicating if it’s unavailable due to scheduled servicing.\n(Future simulations might add factors like weather grounding).\n\n\nHere’s a simple way to visualize a Resource Entity:\n\n\n\n\n\ngraph TD\n    Resource(\"HEMS Resource Entity\") --&gt; Callsign(\"Callsign: H70\");\n    Resource --&gt; Type(\"Type: Helicopter\");\n    Resource --&gt; Capability(\"Capability: CC\");\n    Resource --&gt; Reg(\"Registration: g-daan\");\n    Resource --&gt; Rota(\"Rota: 07:00-19:00 (Winter)\");\n    Resource --&gt; Status(\"Status: Available?\");\n    Status --&gt; OnShift{\"On Shift? (Yes)\"};\n    Status --&gt; Busy{\"Busy? (No)\"};\n    Status --&gt; Servicing{\"Servicing? (No)\"};\n\n\n\n\n\n\nHow the Simulation Uses Resource Entities\nThe Resource Management (Availability & Allocation) system is the main user of these entities. When a Patient Entity needs help:\n\nFiltering: Resource Management looks through all the available HEMS Resource Entities.\nChecking Shift: It checks if the resource’s hems_resource_on_shift status is true for the current simulation time (using its rota details).\nChecking Status: It verifies if the resource is not in_use and not being_serviced.\nMatching Needs: It checks if the resource’s category (CC/EC) and vehicle_type match the patient’s needs.\nAllocation: If a suitable, available resource is found, Resource Management:\n\nAssigns it to the patient.\nSets the resource’s in_use status to True.\n\nRelease: Once the resource finishes its task (e.g., patient handed over, returned to base), Resource Management sets its in_use status back to False, making it available again.\n\nUnder the Hood: The HEMS Class\nThe blueprint for creating these resource profiles is defined in a Python file called class_hems.py. It contains a class named HEMS. Remember, a class is like a template.\n# In class_hems.py (Simplified Structure)\nimport pandas as pd\nfrom class_ambulance import Ambulance # HEMS is a type of Ambulance\n\nclass HEMS(Ambulance): # Inherits from Ambulance class\n    # The __init__ method is called when a new HEMS object is created\n    def __init__(\n            self,\n            callsign: str,\n            vehicle_type: str,\n            category: str, # e.g., 'CC' or 'EC'\n            registration: str,\n            summer_start: str, winter_start: str, # Rota times\n            summer_end: str, winter_end: str,\n            servicing_schedule: pd.DataFrame, # Pre-calculated service dates\n            # ... other parameters ...\n        ):\n        # Call the parent class constructor\n        super().__init__(ambulance_type=\"HEMS\")\n\n        # Store the provided information as attributes of this object\n        self.callsign = callsign\n        self.vehicle_type = vehicle_type\n        self.category = category\n        self.registration = registration\n        self.summer_start = summer_start\n        self.winter_start = winter_start\n        self.summer_end = summer_end\n        self.winter_end = winter_end\n        self.servicing_schedule = servicing_schedule # Holds service start/end dates\n\n        # Status flags (managed by the simulation)\n        self.in_use = False       # Is it currently on a job?\n        self.being_serviced = False # Is it currently in maintenance?\n        # ... other attributes like callsign_group ...\n\n    # Method to check if the resource is working at a given time\n    def hems_resource_on_shift(self, hour: int, season: int) -&gt; bool:\n        # Determines start/end based on season (summer/winter)\n        start = self.summer_start if season in self.summer_season else self.winter_start\n        end = self.summer_end if season in self.summer_season else self.winter_end\n        # Uses a utility function to check if 'hour' is within the start/end range\n        return self.utilityClass.is_time_in_range(int(hour), int(start), int(end))\n\n    # Method to check if unavailable due to servicing at a given time\n    def unavailable_due_to_service(self, current_dt: pd.Timestamp) -&gt; bool:\n        # Loop through the pre-calculated servicing schedule\n        for index, row in self.servicing_schedule.iterrows():\n            # Check if current_dt falls within a service period\n            if row['service_start_date'] &lt;= current_dt &lt;= row['service_end_date']:\n                self.being_serviced = True # Update status flag\n                return True # It is unavailable\n        # If no overlap found\n        self.being_serviced = False # Update status flag\n        return False # It is available (regarding service)\n\n__init__(...): This special function is the constructor. When a new HEMS object is created, this function runs, taking the resource’s details (callsign, type, rota, etc.) as input and storing them within the object itself (e.g., self.callsign = callsign).\nhems_resource_on_shift(...): This is a function belonging to the HEMS object. Given the current hour and season (quarter of the year), it checks the object’s own rota times (self.summer_start, etc.) to see if it should be working.\nunavailable_due_to_service(...): This function checks the object’s servicing_schedule (which was calculated and stored when the object was created) against the current simulation date and time (current_dt) to see if it’s in the garage for maintenance. It also updates the self.being_serviced flag.\n\nCreating the Resources\nThese HEMS objects aren’t created one by one in the main simulation logic. Instead, they are typically prepared at the start by the Resource Management (Availability & Allocation) system, specifically within the HEMSAvailability class in class_hems_availability.py.\n# In class_hems_availability.py (Simplified concept from prep_HEMS_resources)\n\n# Read HEMS details from data files\nHEMS_RESOURCES_DATA = pd.read_csv(\"actual_data/HEMS_ROTA.csv\")\n# ... merge with registration and servicing info ...\n\n# Loop through each row in the data file\nfor index, row in HEMS_RESOURCES_DATA.iterrows():\n    # Calculate the specific service schedule for this registration\n    service_df = calculate_service_dates(row['registration'], ...) # Simplified\n\n    # Create a new HEMS object using the class blueprint\n    hems_object = HEMS(\n        callsign=row['callsign'],\n        vehicle_type=row['vehicle_type'],\n        category=row['category'],\n        registration=row['registration'],\n        summer_start=row['summer_start'],\n        # ... other details from the 'row' ...\n        servicing_schedule=service_df\n    )\n    # Add the newly created object to a list of all resources\n    self.HEMS_resources_list.append(hems_object)\n\n# Later, these objects are put into a SimPy Store for management\n# for h in self.HEMS_resources_list:\n#    self.store.put(h)\nThis setup code reads configuration files (like actual_data/HEMS_ROTA.csv which defines the callsigns, types, and rotas) and uses the HEMS class as a template to create an object for each resource listed. It also calculates and attaches the specific maintenance schedule (servicing_schedule) to each object.\nConclusion\nThe HEMS Resource Entity is the digital twin of a specific helicopter or car in the simulation. It bundles together all the essential information: its name (callsign), type, medical capability, working hours (rota), and unique registration. Crucially, it also holds information about its current status – whether it’s busy (in_use) or out for maintenance (being_serviced).\nThese resource entities are the fundamental building blocks that the simulation uses to represent the available fleet. Understanding them is key to grasping how the system checks for availability and assigns the right help to patients.\nIn the next chapter, we’ll see exactly how the simulation manages these resources – deciding which one to pick when multiple are available, and how it handles situations when no suitable resource is free.\nNext: Chapter 5: Resource Management (Availability & Allocation)\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Components",
      "Chapter 4: HEMS Resource Entity"
    ]
  },
  {
    "objectID": "06_stochastic_modeling__distributions__.html",
    "href": "06_stochastic_modeling__distributions__.html",
    "title": "Chapter 6: Stochastic Modeling (Distributions)",
    "section": "",
    "text": "Chapter 6: Stochastic Modeling (Distributions)\nIn Chapter 5: Resource Management (Availability & Allocation), we saw how the simulation acts like a dispatcher, assigning available helicopters and cars to incoming emergencies. But when a resource is assigned, how does the simulation know how long things will take? How long to get ready (mobilisation)? How long to fly to the scene? How long will the crew spend treating the patient?\nThe Problem: The Real World is Messy and Unpredictable\nImagine we set the simulation so that mobilisation always takes exactly 5 minutes, flying to the scene always takes 12 minutes, and time on scene is always 25 minutes. This might be easy to program, but it’s not realistic!\nIn reality:\n\nSometimes crews mobilise faster, sometimes slower.\nFlight times depend on wind, exact location, and air traffic.\nTime on scene varies hugely depending on the patient’s condition and the complexity of the incident.\nCalls don’t arrive like clockwork; sometimes many come close together, sometimes there are long quiet periods.\nPatients aren’t all the same; they have different ages, conditions, etc.\n\nIf we use fixed numbers, our simulation won’t accurately reflect the variability and randomness of the real world. The results might look too neat and predictable, potentially leading to wrong conclusions about resource needs or performance.\nThe Solution: Using Loaded Dice (Based on Reality!)\nThis is where Stochastic Modeling comes in. “Stochastic” just means involving randomness or probability. Instead of fixed values, we use statistical distributions to model key parameters.\nThink of it like using loaded dice in our simulation game. But instead of loading them unfairly, we load them based on real-world statistics gathered from historical data.\n\nInstead of mobilisation always being 5 minutes, the simulation “rolls the dice” and gets a value like 4.2 minutes, 5.8 minutes, or maybe even 7.1 minutes.\nThese random values aren’t completely chaotic; they follow a specific pattern (a distribution) that matches what we’ve observed in the past. Maybe most mobilisations are around 5 minutes, but some are shorter and some are longer, following a sort of bell curve.\n\nThis introduces realistic variability and makes the simulation behave much more like the actual HEMS system.\nWhat Are Distributions?\nA statistical distribution is just a mathematical way to describe the likelihood of different outcomes. Some common examples:\n\nNormal Distribution (Bell Curve): Many values cluster around the average, with fewer values further away (e.g., human height).\nExponential Distribution: Often used for time between events; short times are common, long times are rare (e.g., time until the next customer arrives).\nUniform Distribution: Every value within a range is equally likely (e.g., rolling a standard fair die).\nPoisson Distribution: Used for counting events in a fixed time (e.g., number of calls per hour).\n\nOur simulation doesn’t need to know the complex math behind these. It just needs to know which distribution to use for a specific variable and what the parameters of that distribution are (e.g., for a normal distribution, the average and the spread).\nWhere Are Distributions Used in DAA_DES?\nWe use distributions derived from historical data for many key aspects:\n\nInter-arrival Times: How long until the next emergency call arrives? This often follows patterns based on the time of day and day of the week. (des_hems.py uses logic based on distribution_data/hourly_arrival_by_qtr_probs.csv and probabilities).\nActivity Durations: How long does each stage of the patient journey take?\n\nTime to allocate resource (time_allocation)\nTime to get mobile (time_mobile)\nTime to reach the scene (time_to_scene)\nTime spent on scene (time_on_scene)\nTime to fly/drive to hospital (time_to_hospital)\nTime until the resource is clear/available again (time_to_clear) These are looked up and sampled primarily by the Utils.activity_time function in utils.py, using definitions from distribution_data/activity_time_distributions.txt.\n\nPatient Characteristics:\n\nAMPDS Code: What type of emergency is it likely to be, based on the hour? (Utils.ampds_code_selection in utils.py, using distribution_data/hour_by_ampds_card_probs.csv).\nAge: How old is the patient, given the type of emergency? (Utils.age_sampling in utils.py, using distribution_data/age_distributions.txt).\nSex: Is the patient male or female, given the type of emergency? (Utils.sex_selection in utils.py, using distribution_data/sex_by_ampds_card_probs.csv).\nCare Category: Does the patient need Critical Care (CC) or Emergency Care (EC)? (Utils.care_category_selection in utils.py).\n\n\nBy using distributions for these, the simulation generates a wide range of plausible scenarios, reflecting real-world randomness.\nPreparing the Distributions: distribution_fit_utils.py\nHow do we know which distribution and parameters to use for, say, ‘time on scene’ for a helicopter? We analyse historical data!\nThis is the job of the script distribution_fit_utils.py. Think of this script as a data scientist that runs before the main simulation. Its process is roughly:\n\nLoad Data: Read a large dataset of past HEMS incidents (e.g., from external_data/clean_daa_import.csv).\nFilter Data: Select the relevant data points (e.g., all ‘time on scene’ values for helicopter incidents where the patient was conveyed).\nFit Distributions: Use a statistical library (like Fitter) to try fitting various standard distributions (Normal, Exponential, Gamma, etc.) to the selected data.\nChoose Best Fit: The library helps determine which distribution provides the “best fit” to the historical data.\nSave Results: Save the name of the best-fitting distribution and its calculated parameters (e.g., for a Gamma distribution, the shape ‘a’ and scale ‘scale’ parameters) into configuration files.\n\nThese resulting configuration files are typically stored in the distribution_data/ folder. For example:\n\ndistribution_data/activity_time_distributions.txt: Stores the best distributions for mobilisation time, scene time, etc., often broken down by vehicle type and outcome.\ndistribution_data/age_distributions.txt: Stores the best distributions for patient age, broken down by the type of emergency (AMPDS code).\nVarious .csv files storing probabilities (e.g., hour_by_ampds_card_probs.csv).\n\nImportant: You usually don’t need to run distribution_fit_utils.py yourself unless the historical data changes significantly or you want to re-analyse it. The pre-calculated files in distribution_data/ allow the main simulation to run.\nHow the Simulation Uses the Prepared Distributions\nThe Simulation Engine (Patient Journey) relies heavily on helper functions within utils.py to get these random values. Let’s look at a key example: getting an activity duration.\nInside the patient_journey function in des_hems.py, you see lines like this:\n# In des_hems.py (simplified 'patient_journey' function)\n\n# --- Mobilisation Time ---\n# Ask the Utils class for a realistic mobilisation time\n# based on the vehicle type (e.g., 'helicopter')\nmobilisation_time = self.utils.activity_time(patient.hems_vehicle_type, 'time_mobile')\n# Use simpy to wait for that randomly generated duration\nyield self.env.timeout(mobilisation_time)\nself.add_patient_result_row(patient, \"HEMS mobile\", \"queue\") # Record event\n\n# --- Time To Scene ---\n# Ask for a realistic travel time\ntts_time = self.utils.activity_time(patient.hems_vehicle_type, 'time_to_scene')\nyield self.env.timeout(tts_time) # Wait\nself.add_patient_result_row(patient, \"HEMS on scene\", \"queue\") # Record event\n\n# --- Time On Scene ---\n# Ask for a realistic time spent on scene\ntos_time = self.utils.activity_time(patient.hems_vehicle_type, 'time_on_scene')\nyield self.env.timeout(tos_time) # Wait\nself.add_patient_result_row(patient, \"HEMS leaving scene\", \"queue\") # Record event\n\n# ... other steps ...\nThis code doesn’t contain fixed numbers like yield self.env.timeout(5). Instead, it calls self.utils.activity_time(...) each time it needs a duration. This function handles the “dice rolling” based on the pre-calculated distributions.\nUnder the Hood: Utils.activity_time and SeededDistribution\nLet’s peek inside utils.py to see how activity_time (conceptually) works:\n# In utils.py (Conceptual Simplified Version)\nimport scipy.stats # Library for statistical distributions\nimport numpy as np # Library for numerical operations\n\nclass SeededDistribution:\n    # This class holds a specific distribution (like 'gamma')\n    # and its parameters, along with a dedicated random number generator (rng)\n    # to ensure consistent random sequences if needed.\n    def __init__(self, dist_function, rng, **params):\n        self.dist = dist_function(**params) # Create the distribution object\n        self.rng = rng                      # Store the random generator\n\n    def sample(self):\n        # Generate one random number from this specific distribution\n        # using its dedicated generator.\n        return self.dist.rvs(random_state=self.rng)\n\nclass Utils:\n    def __init__(self, master_seed=None, ...):\n        # ... (other initialisation) ...\n\n        # 1. Load pre-calculated distributions (from files) when Utils starts\n        # self.activity_time_distr would look something like:\n        # { ('helicopter', 'time_mobile'): SeededDistribution(scipy.stats.gamma, rng1, a=2.5, scale=2.0),\n        #   ('car', 'time_mobile'): SeededDistribution(scipy.stats.lognorm, rng2, s=0.8, scale=4.5),\n        #   ('helicopter', 'time_to_scene'): SeededDistribution(scipy.stats.weibull_min, rng3, c=1.5, scale=10.0),\n        #   ... etc for all combinations ... }\n        self.activity_time_distr = self._load_activity_distributions(master_seed)\n        self.min_max_cache = self._load_min_max_times() # Load acceptable time ranges\n\n    def activity_time(self, vehicle_type: str, time_type: str) -&gt; float:\n        \"\"\"Gets a realistic, random duration for a specific activity.\"\"\"\n\n        # 2. Look up the correct SeededDistribution object based on inputs\n        dist_object = self.activity_time_distr.get((vehicle_type, time_type))\n        if dist_object is None:\n            raise ValueError(f\"No distribution found for {vehicle_type}, {time_type}\")\n\n        # 3. Look up the min/max acceptable times for this activity type\n        min_time, max_time = self.min_max_cache[time_type]\n\n        # 4. Keep sampling until we get a value within the acceptable range\n        sampled_time = -1.0\n        while not (min_time &lt;= sampled_time &lt;= max_time):\n            sampled_time = dist_object.sample() # \"Roll the loaded dice\"\n\n        # 5. Return the realistic, randomly sampled time\n        return sampled_time\n\n    def _load_activity_distributions(self, master_seed):\n        # This private helper function (simplified):\n        # - Reads 'distribution_data/activity_time_distributions.txt'\n        # - Sets up separate random number generators (RNGs) for each distribution\n        #   (using numpy.random.default_rng and SeedSequence from master_seed)\n        #   for better statistical properties and reproducibility.\n        # - Creates the SeededDistribution objects and stores them in a dictionary.\n        # ... implementation details omitted ...\n        seeded_distributions = {} # Dictionary to hold the results\n        # ... code to read file, create RNGs, create SeededDistribution objects ...\n        return seeded_distributions # Return the dictionary like the example above\n\n    def _load_min_max_times(self):\n        # Reads 'actual_data/upper_allowable_time_bounds.csv' into a lookup dictionary\n        # ... implementation details omitted ...\n        cache = {}\n        # ... code to read file and populate cache ...\n        return cache\n\n    # Other utility functions like age_sampling, sex_selection work similarly:\n    # - Look up probabilities or distribution parameters from loaded data.\n    # - Use a dedicated random number generator to sample or make a choice.\n    # def age_sampling(self, ampds_card: int, max_age: int) -&gt; float: ...\n    # def sex_selection(self, ampds_card: int) -&gt; str: ...\nKey Ideas from the Code:\n\nPre-calculation: The distributions are figured out beforehand by distribution_fit_utils.py and loaded when the Utils class starts.\nLookup: The activity_time function finds the correct pre-loaded distribution based on the vehicle_type and time_type.\nSampling: It calls the sample() method of the SeededDistribution object, which uses a dedicated random number generator (rng) and the specific distribution function (scipy.stats.gamma, scipy.stats.lognorm, etc.) to generate a random value following the historical pattern.\nBounds Checking: It ensures the sampled time is within realistic minimum and maximum limits defined in actual_data/upper_allowable_time_bounds.csv.\nSeeding: The use of master_seed, SeedSequence, and default_rng ensures that if you run the simulation with the same seed, you will get the exact same sequence of “random” numbers, making the simulation reproducible for testing and debugging.\n\nSimplified Data Flow:\nHere’s how the pieces fit together:\n\n\n\n\n\ngraph LR\n    A[Historical Data (CSV)] --&gt; B(distribution_fit_utils.py);\n    B -- Analyzes Data --&gt; C{Distribution Files (distribution_data/)};\n    C -- Loaded at Start --&gt; D(Utils Class);\n    E[Simulation Engine (des_hems.py)] -- Needs Random Value --&gt; D;\n    D -- Looks up Distribution & Samples --&gt; F[Realistic Random Value (e.g., 11.5 min)];\n    E -- Uses Value --&gt; G(Simulation Progresses);\n\n\n\n\n\n\nConclusion\nStochastic modeling, using statistical distributions, is essential for making the DAA_DES simulation realistic. Instead of using fixed, unrealistic numbers, the simulation samples values from distributions that are carefully chosen based on historical data. This ensures that factors like call arrival times, activity durations, and patient details vary randomly but follow patterns observed in the real world.\nThe distribution_fit_utils.py script performs the initial analysis of historical data to determine these distributions, saving them to files. The main simulation engine then uses functions in utils.py (like activity_time) to “roll the dice” according to these pre-calculated distributions whenever it needs a random but realistic value. This randomness is key to exploring the range of possible outcomes and getting meaningful insights from the simulation.\nSo far, we’ve seen the interface, the engine directing the flow, the patient and resource entities, how resources are managed, and how randomness is introduced. But how do we actually run the simulation, potentially multiple times to account for this randomness, and do it efficiently? That’s the focus of the next chapter.\nNext: Chapter 7: Simulation Runner & Parallelization\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Components",
      "Chapter 6: Stochastic Modeling (Distributions)"
    ]
  },
  {
    "objectID": "08_results_processing___visualization_.html",
    "href": "08_results_processing___visualization_.html",
    "title": "Chapter 8: Results Processing & Visualization",
    "section": "",
    "text": "Chapter 8: Results Processing & Visualization\nWelcome to the final chapter! In Chapter 7: Simulation Runner & Parallelization, we saw how the simulation is run multiple times (replications) to account for randomness, and how all the raw data from these runs is gathered into a single big file, usually called data/run_results.csv.\nBut what do we do with this big file? It contains thousands, maybe millions, of rows detailing every little event that happened in every simulation run. Just looking at the raw data won’t tell us much about overall performance or answer questions like “Did adding that extra car actually help?”\nWhat Problem Does This Solve? The Need for Insights\nImagine you’re a manager who just received a massive spreadsheet listing every single sale made last year – every item, every customer, every timestamp. Useful data, perhaps, but overwhelming! What you really need is a report summarizing:\n\nTotal sales this year vs. last year.\nAverage sale value.\nBusiest sales hours.\nA chart showing monthly sales trends.\n\nOur simulation output (run_results.csv) is like that raw sales spreadsheet. The Results Processing & Visualization component acts like the analytics department. It takes this raw simulation log data and transforms it into meaningful insights. It calculates key performance indicators (KPIs), creates charts, and compares the simulation’s output to historical data, presenting everything clearly in the Web Application Interface (Streamlit).\nFrom Raw Data to Clear Results: The Workflow\nThis component performs several key tasks, mostly handled by Python scripts found in the visualisation/ folder:\n\nLoad Data: It reads the combined results file (data/run_results.csv) generated by the Simulation Runner & Parallelization. It also loads relevant historical data from files typically stored in the historical_data/ folder.\nProcess & Calculate: It cleans and structures the data. Then, it performs calculations using libraries like pandas to determine important metrics (KPIs):\n\nResource Utilization: What percentage of their available time were helicopters and cars busy? (Uses functions in visualisation/_utilisation_result_calculation.py)\nJob Counts: How many jobs were handled per month, per hour, or per day? How many were potentially missed? (Uses functions in visualisation/_job_count_calculation.py)\nActivity Timings: How long did key activities like mobilisation or time on scene take, on average? (Uses functions in visualisation/_job_time_calcs.py)\nProcess Flow: Analyzing the sequence of events. (Uses functions in visualisation/_process_analytics.py)\n\nCompare: It compares the calculated metrics from the simulation against the loaded historical data. For example, comparing the simulated average monthly jobs to the actual average monthly jobs from past years.\nGenerate Outputs: It creates:\n\nKPI values: Single numbers representing key metrics (e.g., average H70 utilisation = 25.3%).\nTables: Structured summaries of data (e.g., a table showing utilisation for each resource).\nPlots: Visual charts (e.g., line charts, bar charts, box plots) created using libraries like plotly.\n\nDisplay: These generated KPIs, tables, and plots are then passed back to the Streamlit application (app/model.py), which uses functions like st.metric, st.dataframe, and st.plotly_chart to display them neatly in the web interface tabs.\n\nExample 1: Calculating a KPI (Resource Utilization)\nLet’s say we want to calculate the average utilization for the H70 helicopter across all simulation runs.\n\nInput: data/run_results.csv (need columns like run_number, callsign, event_type, timestamp_dt) and data on H70’s scheduled availability (from Resource Management (Availability & Allocation)).\nLogic (Simplified):\n\nFilter run_results.csv to get only the ‘resource_use’ and ‘resource_use_end’ events for ‘H70’.\nFor each job H70 attended in each run, calculate the time duration between ‘resource_use’ and ‘resource_use_end’.\nSum these durations for H70 within each run_number. This gives the total time H70 was busy in each run.\nDetermine the total time H70 was available during the simulation (considering its rota and any maintenance, calculated by helper functions perhaps using visualisation/_vehicle_calculation.py).\nFor each run, divide the total busy time by the total available time to get the utilisation percentage for that run.\nCalculate the average of these utilisation percentages across all runs.\n\nCode: The actual calculation happens inside functions within visualisation/_utilisation_result_calculation.py. A simplified conceptual snippet might look like:\n# In visualisation/_utilisation_result_calculation.py (Conceptual)\nimport pandas as pd\n# Assume 'resource_use_wide' DataFrame has columns:\n# 'run_number', 'callsign', 'resource_use_duration' (in minutes)\n# Assume 'total_avail_minutes' DataFrame has columns:\n# 'callsign', 'total_available_minutes_in_sim'\n\ndef calculate_average_utilisation(resource_use_wide, total_avail_minutes):\n    # Sum busy time per run and callsign\n    utilisation_per_run = resource_use_wide.groupby(['run_number', 'callsign'])['resource_use_duration'].sum().reset_index()\n\n    # Merge with available time\n    utilisation_per_run = utilisation_per_run.merge(total_avail_minutes, on='callsign')\n\n    # Calculate percentage utilisation for each run\n    utilisation_per_run['perc_time_in_use'] = (\n        utilisation_per_run['resource_use_duration'] /\n        utilisation_per_run['total_available_minutes_in_sim']\n    )\n\n    # Calculate the average across all runs for each callsign\n    average_utilisation = utilisation_per_run.groupby('callsign')['perc_time_in_use'].mean().reset_index()\n\n    # Format as percentage string for display\n    average_utilisation['PRINT_perc'] = average_utilisation['perc_time_in_use'].apply(lambda x: f\"{x:.1%}\")\n    return average_utilisation # Return a DataFrame with results per callsign\nDisplay: The Streamlit app (app/model.py) calls this calculation function and then uses st.metric to show the result:\n# In app/model.py (Simplified)\nimport streamlit as st\nimport visualisation._utilisation_result_calculation as util_calcs\n\n# ... (simulation runs and results_all_runs DataFrame is loaded) ...\n\n# Call the function to calculate utilisation\n# (This function internally processes results_all_runs)\nresource_use_wide, utilisation_df_overall, _, _ = util_calcs.make_utilisation_model_dataframe(...)\n\n# Get the specific value for H70\nh70_util_fig = utilisation_df_overall[utilisation_df_overall['callsign']=='H70']['PRINT_perc'].values[0]\n\n# Display it using Streamlit's metric widget\nst.metric(\"Average Simulated H70 Utilisation\", h70_util_fig)\n\nExample 2: Generating a Visualization (Monthly Jobs Plot)\nLet’s create a plot showing the average number of jobs per month in the simulation compared to historical data.\n\nInput: data/run_results.csv (need run_number, P_ID, timestamp_dt, time_type) and a historical data file like historical_data/historical_monthly_totals_all_calls.csv.\nLogic (Simplified):\n\nFilter run_results.csv for ‘arrival’ events (each arrival represents a potential job).\nExtract the month and year from the timestamp_dt for each arrival.\nGroup the data by run_number and month, then count the number of arrivals (P_IDs) in each group. This gives the monthly job count for each run.\nFor each month, calculate the average count across all runs. Also, calculate measures of variation (like min/max or percentiles) across the runs for that month.\nLoad the historical monthly job counts from the CSV file.\nUse plotly to generate a line chart:\n\nOne line for the average simulated monthly count.\nA shaded area around the average line representing the variation (e.g., min to max) across runs.\nAnother line or shaded area representing the historical data range.\n\n\nCode: Functions in visualisation/_job_count_calculation.py handle this.\n# In visualisation/_job_count_calculation.py (Conceptual)\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\n\ndef plot_monthly_calls(call_df, historical_monthly_job_data_path, ...):\n    # Assume 'call_df' has arrival data per patient/run\n\n    # Extract month\n    call_df['timestamp_dt'] = pd.to_datetime(call_df['timestamp_dt'])\n    call_df['month_start'] = call_df['timestamp_dt'].dt.to_period('M').dt.to_timestamp()\n\n    # Calculate monthly calls per run\n    call_counts_monthly = call_df.groupby(['run_number', 'month_start'])['P_ID'].count().reset_index()\n    # ... (filter out partial start/end months) ...\n\n    # Calculate average and variation (min/max) across runs\n    summary = call_counts_monthly.groupby('month_start')['monthly_calls'].agg(['mean', 'min', 'max']).reset_index()\n\n    # Load historical data\n    historical_data = pd.read_csv(historical_monthly_job_data_path)\n    # ... (process historical data similarly) ...\n\n    # Create plot using Plotly\n    fig = go.Figure()\n    # Add shaded region for simulation range (min to max)\n    fig.add_traces(...) # Min/Max lines with fill='tonexty'\n    # Add line for simulation average\n    fig.add_trace(go.Scatter(x=summary['month_start'], y=summary['mean'], name='Simulated Average', ...))\n    # Add line/region for historical data\n    fig.add_traces(...) # Historical data\n\n    fig.update_layout(title=\"Monthly Calls: Simulation vs Historical\", ...)\n    return fig # Return the Plotly figure object\nDisplay: The Streamlit app (app/model.py) calls this plotting function and displays the generated figure.\n# In app/model.py (Simplified)\nimport streamlit as st\nimport visualisation._job_count_calculation as job_calcs\n\n# ... (simulation runs and results_all_runs DataFrame is loaded) ...\n# Prepare the 'call_df' needed by the plotting function\ncall_df = job_calcs.make_job_count_df(path=\"data/run_results.csv\", ...)\n\n# Call the function to generate the plot\nfig_monthly_calls = job_calcs.plot_monthly_calls(\n    call_df,\n    historical_monthly_job_data_path=\"historical_data/historical_monthly_totals_all_calls.csv\",\n    # ... other plot options ...\n)\n\n# Display the figure using Streamlit\nst.plotly_chart(fig_monthly_calls)\n\nUnder the Hood: The Analysis Pipeline\nWhen you click “Run Simulation” and it finishes, a sequence of processing steps leads to the results you see:\n\n\n\n\n\nsequenceDiagram\n    participant App as Streamlit App (app/model.py)\n    participant Collator as Result Collator (Ch 7)\n    participant VisUtil as Utilisation Calcs (visualisation/*)\n    participant VisJobs as Job Count Calcs (visualisation/*)\n    participant Plotly as Plotting Library\n\n    Note over App, Collator: Simulation Finished\n    App-&gt;&gt;Collator: collateRunResults()\n    Collator--&gt;&gt;App: run_results.csv ready\n    Note over App: Load run_results.csv into DataFrame\n\n    App-&gt;&gt;VisUtil: Calculate Utilisation(results_df)\n    VisUtil-&gt;&gt;VisUtil: Load historical util data (CSV)\n    VisUtil-&gt;&gt;VisUtil: Process data (Pandas: filter, group, calc durations)\n    VisUtil--&gt;&gt;App: Return Utilisation KPIs & Tables\n\n    App-&gt;&gt;VisJobs: Generate Monthly Jobs Plot(results_df)\n    VisJobs-&gt;&gt;VisJobs: Load historical job counts (CSV)\n    VisJobs-&gt;&gt;VisJobs: Process data (Pandas: filter, group, count, average)\n    VisJobs-&gt;&gt;Plotly: Create Plotly figure with sim & historical data\n    Plotly--&gt;&gt;VisJobs: Return Figure Object\n    VisJobs--&gt;&gt;App: Return Figure Object\n\n    Note over App: Display results in tabs\n    App-&gt;&gt;App: Display KPIs (st.metric(utilisation_kpi))\n    App-&gt;&gt;App: Display Plots (st.plotly_chart(jobs_figure))\n\n\n\n\n\n\nEssentially, the scripts in the visualisation/ folder act as specialized calculators and chart generators. They take the raw simulation log, perform specific analyses using pandas, often incorporate historical data for context, and produce outputs (numbers, tables, plotly figures) that the main Streamlit application (app/model.py) can then easily display.\nConclusion\nThe Results Processing & Visualization component is the crucial final step that transforms the raw output of our complex simulation into understandable information. By calculating key metrics like resource utilization and job counts, comparing them against historical benchmarks, and generating clear plots and tables, it allows users to effectively interpret the simulation’s findings directly within the Web Application Interface (Streamlit). This enables informed decision-making based on the simulation scenarios tested.\nThis concludes our tutorial series on the DAA_DES project. We hope this journey through the web interface, the simulation engine, the core entities (patients and resources), resource management, stochastic modeling, the simulation runner, and finally results processing has given you a clear understanding of how this powerful tool works!```\n\nGenerated by AI Codebase Knowledge Builder",
    "crumbs": [
      "Components",
      "Chapter 8: Results Processing & Visualization"
    ]
  }
]